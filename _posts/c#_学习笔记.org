#+title:    c#学习笔记
#+author:   张鹏帅
#+date:     2020-11-11

** 封装
即隐藏对象的属性和实现细节,仅对外公开接口.

即"不要告诉我你是怎么做的,只要做就可以了."

** 类与对象
对象是通过类new出来的.

一个对象是对客观事物的抽象,类是对对象的抽象.对象是类的实例,类是对象的模板.

** 访问修饰符
类的默认访问标识符是 internal，成员的默认访问标识符是 private。
- public：所有对象都可以访问
成员可以被任何代码访问.
能不能靠谱点,什么任何,任何是什么意思!!

新建两个项目A,B.A引用B,B中有两个类,一个internal一个public,A中无法访问internal的类,可以访问public的类.
- private：对象本身在对象内部可以访问
成员仅能被同一个类中的代码访问
- internal：同一个程序集的对象可以访问
成员仅能被同一个项目中的代码访问.
- protected：只有该类对象及其子类对象可以访问
成员只能由类或才派生类中的代码访问.
- protected internal：访问限于当前程序集或派生自包含类的类型
*** 类
*** 成员(成员变量,成员方法)
** 声明修饰符
- static
  1. 静态类不能实例化
  
  |            | static类                      | 实例类                        |
  |------------+-------------------------------+-------------------------------|
  | static成员 | 可直接使用其中的成员          | 只能通过类名.static成员来引用 |
  |            | animal.name;                  | (实例名.static成员会报错)     |
  |            | animal.printAnimal();         |                               |
  |------------+-------------------------------+-------------------------------|
  | 实例成员   | 无,不能在静态类中声明实例成员 | 这是正常的实例类,别学傻了     |

- abstract
  1. 抽象类不能实例化,主要是为了被继承,指明"我是其他类基类";抽象类的派生类可以实例化
  2. 抽象方法是不带方法体的方法,仅包含方法的定义;其定义的实现都在派生类中
  3. 抽象成员必须定义在抽象类中
  4. abstract对字段无效,可改用属性

  |              | abstract类                                        | 实例类                    |
  |--------------+---------------------------------------------------+---------------------------|
  | abstract成员 | 抽象成员只能必须定义在抽象类中                    | 无                        |
  |--------------+---------------------------------------------------+---------------------------|
  | 实例成员     | abstract对字段无效,抽象方法会在派生类中被override | 这是正常的实例类,别学傻了 |

- virtual
  就是等着被重写呢.只有标记为virtual,abstract,override的才能被重写.

- new

- override:代表重写

- sealed
  与override联用,表示这个被重写的类不能被再次重写了.

** 重载overload
*** 函数重载
名称一样,但是参数不一样的函数.
*** 运算符重载
假如说你定义了一个怪兽类,有物理攻击100,法术攻击100.现有怪兽+怪兽=大怪兽(相较怪兽来说
物理攻击增加30%,法术攻击增加20%)这种运算,基本的加法运算符无法满足,此时可将加法运算符重新
定义成适合怪兽类对象的"怪兽加法运算符".
** 类的成员
- 字段
- 属性
- 方法
#+begin_src c
class Monster
{
    private int blod;
    private int attack;
    private int defence;

    public int Blod
    {
        get
        {
            return blod;
        }

        set
        {
            blod = value;
        }
    }

    public int Attack
    {
        get
        {
            return attack;
        }

        set
        {
            attack = value;
        }
    }

    public int Defence
    {
        get
        {
            return defence;
        }

        set
        {
            defence = value;
        }
    }

    public void getHurt()
    {
        blod--;
        blod--;
        blod--;
        defence--;
        defence--;
    }

    public void showMe()
    {
        Console.WriteLine("我的血量还有:{0}\n", blod);
        Console.WriteLine("我的攻击是:{0}\n", attack);
        Console.WriteLine("我的防御还有:{0}\n", defence);
        return;
    }
}
#+end_src
- blod就是字段
- Blod就是属性(属性的本质就是一个方法)

  外界访问字段的入口.
- showMe就是方法

** 接口
1. 接口是为了实现多重继承而设计的.
2. 接口之间可以继承
3. 一个类可以继承多个接口
4. 接口不能直接实例化,需要通过类
5. 接口中的成员必须全部都实现,否则该类必须声明为抽象类,并在抽象类中将未实现的接口成员以抽象方式实现
*** 接口的定义
#+begin_src c
interface ICompute
{
    int Id { get; set; }
    string Name { get; set; }
    void Total();
    void Avg();
}
#+end_src
*** 接口的实现
#+begin_src c
class ITest : ICompute
{
    public int MathGoal { get; set; }
    public int EnglishGoal { get; set; }
    public int Id { get; set; }
    public string Name { get; set; }

    public void Avg()
    {
        Console.WriteLine((MathGoal + EnglishGoal) / 2);
    }

    public void Total()
    {
        Console.WriteLine(MathGoal + EnglishGoal);
    }
}
interface ICompute
{
    int Id { get; set; }
    string Name { get; set; }

    void Total();
    void Avg();
}
#+end_src
**** 显式

**** 隐式
** 多态
[[https://www.cnblogs.com/zhangkai2237/archive/2012/12/20/2826734.html][C#中的多态性]]
** 重写与隐藏
1. 派生类重写了基类的方法后,基类的方法就不存在了.

   当派生类的实例的类型转换成基类类型的时候,调用实例的方法是派生类的方法.

2. 子类隐藏了基类的方法后.

   当派生类的实例的类型转换成基类类型的时候,调用实例的方法就还是基类的方法
** 解决方案,项目,命名空间
1. 一个解决方案下可以有多个不同的项目?
   - 是
2. 不同的项目声明的同名命名空间的是不是相同的命名空间?
   - 不是
   
   为什么?
   - 因为在同一个项目中相同命名空间中不允许有相同名称的类,而在不同项目中却可以.
** 泛型(Generic)
感觉就是一个通用的类型,哦,这叫泛型.
[[https://www.runoob.com/csharp/csharp-generic.html][C#泛型]]
** TODO 特性(Attribute)
*** 预定义特性
*** 自定义特性
** TODO 集合(Collection)
专门用于数据存储和检索的类.
** 委托
参考: [[https://www.cnblogs.com/SkySoot/archive/2012/04/05/2433639.html][C# 中的委托和事件(详解)]]

委托是一个类,它定义了方法的类型,使得可以将方法当作另一个方法的参数来进行传递,这种将方
法动态地赋给参数的做法,可以避免在程序中大量使用if-else/switch语句,同时使得程序具有更
好的可扩展性.

个人理解:委托就是对跟泛型很像,我定义一个东西说有一上方法返回类型是什么,参数是什么.然后我就可以
定义一个名叫abc的委托指向一个返回类型与参数相同的方法.我用这个委托的名字就相当与调用了刚刚指向
的那个方法.
个人理解2:委托的名称可以当作类型来用,比如一个函数的参数是
(string name,MageGreeting mg)...说不清了,就是可以通过委托给一个方法传递另一个方法.
*** 声明
委托声明决定了可由该委托引用的方法.
#+begin_src c
delegate void printShow(int n);
#+end_src
*** 实例化
#+begin_src c
using System;

delegate void printShow(int n);

namespace DelegateAppl
{
    class TestDelegate
    {
        static void pS1(int n)
        {
            Console.WriteLine(n);
        }
        static void pS2(int n)
        {
            Console.WriteLine(n + n);
        }

        static void Main(string[] args)
        {
            printShow p1 = new printShow(pS1);
            printShow p2 = new printShow(pS2);

            p1(3);
            p2(3);
        }
    }
}
#+end_src
#+begin_src c
using System;

public delegate void GreetingDelegate(string name);

class Program
{
    private static void EnglishGreeting(string name)
    {
        Console.WriteLine("Good Morning, " + name);
    }

    private static void ChineseGreeting(string name)
    {
        Console.WriteLine("早上好, " + name);
    }

    private static void GreetPeople(string name, GreetingDelegate MakeGreeting)
    {
        MakeGreeting(name);
    }

    static void Main(string[] args)
    {
        GreetPeople("Liker", EnglishGreeting);
        GreetPeople("李志中", ChineseGreeting);

        Console.ReadLine();

    }
}
#+end_src
*** 委托的多播
个人理解:委托可以一下调用一个符合委托定义的方法列表.
它会用给的参数挨个的执行方法列表.
#+begin_src c
using System;

delegate void printShow(int n);

namespace DelegateAppl
{
    class TestDelegate
    {
        static void pS1(int n)
        {
            Console.WriteLine(n);
        }
        static void pS2(int n)
        {
            Console.WriteLine(n + n);
        }

        static void Main(string[] args)
        {
            printShow p;
            printShow p1 = new printShow(pS1);
            printShow p2 = new printShow(pS2);
            p = p1 + p2;
            //p1(3);
            //p2(3);
            p(3);
        }
    }
}
#+end_src
** TODO 事件
 个人理解:比如点击事件,按键.
声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已.
** 声明事件
1. 声明事件前需要先声明该事件的委托类型

2. 声明事件本身