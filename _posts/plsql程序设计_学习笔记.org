#+title: PL/SQL 程序设计
#+author: 张鹏帅
#+date: 2020-10-30

* 简介
** 什么是PL/SQL?
一种程序设计语言,专门用于对ORACLE数据库进行访问.
Procedure Language & Structured Query Language的缩写.
** 分类
1. 数据库PL/SQL
2. 工具PL/SQL
** 运行PL/SQL程序
PL/SQL程序通过ORACLE中的引擎来运行.

[[https://baike.baidu.com/item/PL/SQL][百度百科-PL/SQL:]]
#+BEGIN_QUOTE
PL/SQL语句和SQL语句是分别进行解析和执行的。PL/SQL块被数据库内部的PL/SQL引擎提取，
将SQL语句取出送给Oracle的SQL引擎处理，两种语句分别在两种引擎中分析处理，在数据库内部
完成数据交互、处理过程。
#+END_QUOTE
* 块结构和组成元素
** PL/SQL程序块的基本结构
*** 4部分
1. 块头
2. 声明单元
3. 执行单元
4. 异常处理单元
*** PL/SQL程序块可以分为三类
1. 无名块
2. 子程序
3. 触发器

** 变量
*** 变量类型
| 类型        | 子类 | 说明 | 范围 | ORACLE限制 |
|-------------+------+------+------+------------|
| CHAR        |      |      |      |            |
| VARCHAR2    |      |      |      |            |
| BINARY_IN   |      |      |      |            |
| TEGER       |      |      |      |            |
| NUMBER(p,s) |      |      |      |            |
| LONG        |      |      |      |            |
| DATE        |      |      |      |            |
| BOOLEAN     |      |      |      |            |
| ROWID       |      |      |      |            |
| UROWID      |      |      |      |            |
*** 使用%TYPE
作用是获取某个数据变量的类型
*** 运算符
**** 关系运算符
| 运算符      | 意义       |
|-------------+------------|
| =           | 等于       |
| <>,!=,~=,^= | 不不等于   |
| <           | 小于       |
| >           | 大于       |
| <=          | 小于或等于 |
| >=          | 大于或等于      |
**** 一般运算符
| 运算符 | 意义       |
|--------+------------|
| +      | 加         |
| -      | 减         |
| *      | 乘         |
| /      | 除         |
| :=     | 赋值       |
| =>     | 关系号     |
| ..     | 范围运算符 |
| \vert\vert     | 字符连接符 |
**** 逻辑运算符
| 运算符  | 意义         |
|---------+--------------|
| is null | 是空值       |
| between | 介于两者之间 |
| in      | 在一列值中间 |
| and     | 逻辑与       |
| or      | 逻辑或       |
| not     |  取反          |
*** 变量赋值
语法:

    variable := expression;

    variable是一个PL/SQL变量,expression是一个PL/SQL表达式.
*** 数据库赋值 
通过select语句来完成赋值

例子:

** 注释
1. 单行注释 --
2. 多行注释 /* */

* 流程控制语句
** 条件语句
#+BEGIN_SRC sql
IF <布尔表达式> THEN
  PL/SQL 和 SQL 语句
END IF;

IF <布尔表达式> THEN
  PL/SQL 和 SQL 语句
ELSE
  其他语句;
END IF;

IF <布尔表达式> THEN
  PL/SQL 和 SQL 语句
ELSIF <布尔表达式> THEN
  其他语句
END IF;

/*例子*/
DECLARE
   v_id        dept.id%TYPE := 10;
   v_name      dept.name%TYPE;
   v_comment   VARCHAR2 (50);
BEGIN
   SELECT name
     INTO v_name
     FROM dept
    WHERE id = v_id;

   IF v_name = 'Administration'
   THEN
      v_comment := 'yes';
   ELSE
      v_comment := 'no';
   END IF;

   DBMS_OUTPUT.put_line (v_comment);
END;
#+END_SRC    

** CASE表达式
#+BEGIN_SRC sql
CASE selector
  WHEN 'a' THEN 'VERY GOOD'
  WHEN 'b' THEN 'GOOD'
  ELSE 'NOT BED'
END;

/*例子*/
DECLARE
   v_id        dept.id%TYPE := 20;
   v_name      dept.name%TYPE;
   v_comment   VARCHAR2 (50);
BEGIN
   SELECT name
     INTO v_name
     FROM dept
    WHERE id = v_id;

   v_comment := 
   CASE v_name
      WHEN 'Administration' THEN 'yes'
      WHEN 'Marketing' THEN 'no'
      ELSE 'haha'
   END;   
   DBMS_OUTPUT.put_line (v_comment);
END;
#+END_SRC

** 循环

*** LOOP循环
#+BEGIN_SRC sql
/*例子*/
DECLARE
   int   NUMBER (2) := 0;
BEGIN
   LOOP
      int := int + 1;
      DBMS_OUTPUT.put_line ('int now is:' || int);
      EXIT WHEN int > 10;
   END LOOP;
END;
#+END_SRC
*** WHILE循环
#+BEGIN_SRC sql
DECLARE
   x   NUMBER;
BEGIN
   x := 0;

   WHILE x < 10
   LOOP
      DBMS_OUTPUT.put_line (x);
      x := x + 1;
   END LOOP;
END;
#+END_SRC
*** FOR循环
#+BEGIN_SRC sql
BEGIN
   FOR int IN 1 ..5
   LOOP
      DBMS_OUTPUT.put_line ('int now is:' || int);
   END LOOP;
END;

BEGIN
   FOR int IN REVERSE 1 ..5
   LOOP
      DBMS_OUTPUT.put_line ('int now is:' || int);
   END LOOP;
END;
#+END_SRC

** 标号和GOTO
#+BEGIN_SRC sql
DECLARE
   int   NUMBER (2) := 0;
BEGIN
   LOOP
      int := int + 1;

      DBMS_OUTPUT.put_line ('int now is:' || int);

      IF int = 3
      THEN
         GOTO l_ENDofLOOP;
      END IF;
   END LOOP;

  <<l_ENDofLOOP>>
   DBMS_OUTPUT.put_line ('intINTINT now is:' || int);
END;
#+END_SRC
** NULL语句
一条语句,但是不做任何事.可以用来占个坑.

* 游标
** 游标的概念
[[https://baike.baidu.com/item/plsql/9042661?fr=aladdin#6][百度百科-PL/SQL游标]]
#+BEGIN_QUOTE
游标的定义:用游标来指代一个DML SQL操作返回的结果集.即当一个队数据库的查询操作返回一组
结果集时,用游标标注这组结果集,以后通过对有表的操作来获取结果集中的数据信息.
#+END_QUOTE

#+BEGIN_SRC sql
cursor c_emp is select * from emp where emp_id=3;
#+END_SRC

大概类似于C语言中的指针;

大概类似于C语言中打开文件是的文件句柄;

大概类似于Excel中鼠标点选了一行或多行.

** 游标分类

*** 显式游标
显式游标被用于处理返回多行数据的SELECT语句,游标名通过CURSOR...IS语句显式地赋给SELECT语句.
**** 处理显式游标-四个PL/SQL步骤
1. 定义游标:就是定义一个游标名,以及与其对应的SELECT语句
2. 打开游标:就是执行游标所对应的SELECT语句,将其查询结果放入工作区,并且指针指向工作区的首部,标识游标结果集合.
3. 提取游标数据:就是检索结果集合中的数据行,放入指定的输出变量中.
4. 关闭游标:当提取和处理完游标结果集合数据后,应及时关闭游标,以释放该游标所占用的系统资源,并使该由标的工作区变成无效,不能再使用FETCH语句取其中数据.关闭后的游标可以使用OPEN语句重新打开.
#+BEGIN_SRC sql
/*例子*/
DECLARE
   CURSOR c4 (dept_id NUMBER)
   IS
      SELECT empno, ename
        FROM emp
       WHERE empno = dept_id;

   v_emp_record   c4%ROWTYPE;
BEGIN
   OPEN c4 (3333);

   LOOP
      FETCH c4 INTO v_emp_record;

      IF c4%FOUND
      THEN
         DBMS_OUTPUT.put_line ('this person empno is' || v_emp_record.empno);
      ELSE
         DBMS_OUTPUT.put_line ('已经处理完了');
         EXIT;
      END IF;
   END LOOP;

   CLOSE c4;
END;
#+END_SRC
**** 游标属性
| 属性      | 类型    | 含义                     |
|-----------+---------+--------------------------|
| %FOUND    | BOOLEAN | 最近一次读取游标成功与否 |
| %NOTFOUND | BOOLEAN | ...失败与否              |
| %ISOPEN   | BOOLEAN | 游标是否已打开           |
| %ROWCOUNT | NUMBER  | 已从游标中读取的记录数   |
**** 游标的FOR循环
#+BEGIN_SRC sql
/*格式:*/
FOR INDEX IN CURSOR LOOP
/*SOME CODE*/
END LOOP;
#+END_SRC
*** 隐式游标

所有的隐式游标都被假设为只返回一条记录.

隐式游标的名字是SQL,在使用DML语句和单行SELECT语句时会自动创建.

有四个属性:
  - %FOUND
  - %NOTFOUND
  - %ROWCOUNT
  - %ISOPEN
** 游标修改和删除操作
* 异常处理
** 异常处理的概念
就是对意料之外的事件的处理.
** 异常处理的类型
*** 预定义错误
#+BEGIN_SRC sql
/*例子*/
DECLARE
   v_empno   zps_table_temp.empno%TYPE := &p_empno;
   v_sal     zps_table_temp.sal%TYPE;
BEGIN
   SELECT sal
     INTO v_sal
     FROM zps_table_temp
    WHERE empno = v_empno;

   IF v_sal <= 1500
   THEN
      UPDATE zps_table_temp
         SET sal = sal + 100
       WHERE empno = v_empno;

      DBMS_OUTPUT.put_line (
         '编码为' || v_empno || '的员工工资已经更新!\n');
   ELSE
      DBMS_OUTPUT.put_line (
         '编码为' || v_empno || '的员工工资已经超过规定值!\n');
   END IF;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      DBMS_OUTPUT.put_line (
         '编码为' || v_empno || '的员工没有找到!\n');
   WHEN TOO_MANY_ROWS
   THEN
      DBMS_OUTPUT.put_line ('程序运行错误!请使用游标');
   WHEN OTHERS
   THEN
      DBMS_OUTPUT.put_line ('其他错误!');
END;
#+END_SRC
*** 非预定义错误
1. 首先定义一种错误名称
    #+begin_src sql
    exception_name exception;
    #+end_src
2. 再将名称与标准的ORACLE错误联系起来
    #+begin_src sql
    PRAGMA EXCEPTION_INIT(exception_name,exception_number);
    #+end_src
*** 用户定义错误
1. 用户自己定义一个错误名称
    #+begin_src sql
    exception_name exception;

    no_result exception;
    #+end_src
2. 适时地调用它
    #+begin_src sql
    raise no_result;
    #+end_src
3. 在exception块内填入错误执行的代码
    #+begin_src sql
    exception
        when no_result then
            dbms_output.put_line('你的数据更新语句失败了!');
        when others then
            dbms_output.put_line('发生其他错误');
    #+end_src
* 存储函数和存储过程
** 子程序的概念
ORACLE可以把PL/SQL程序存储在数据库中,并且可以在任何地方来运行它.

意思就是,保存在ORACLE数据库中的PL/SQL程序就叫存储过程或函数.

统称为PL/SQL子程序.

过程和函数惟一的区别就是函数返回数据,过程不返回数据.
** 过程
*** 创建存储过程
#+begin_src sql
CREATE [OR REPLACE] PROCEDURE procedure_name 
[(parameter_name [IN | OUT | IN OUT] type [, ...])] 
{IS | AS} 
BEGIN 
  < procedure_body > 
END procedure_name;

/*例子1-无参数*/
CREATE OR REPLACE PROCEDURE greetings 
AS 
BEGIN 
   dbms_output.put_line('Hello World!'); 
END; 
/*例子2-有参数*/
DECLARE 
   a number; 
   b number; 
   c number;
PROCEDURE findMin(x IN number, y IN number, z OUT number) IS 
BEGIN 
   IF x < y THEN 
      z:= x; 
   ELSE 
      z:= y; 
   END IF; 
END;   
BEGIN 
   a:= 12; 
   b:= 35; 
   findMin(a, b, c); 
   dbms_output.put_line('两个数：12, 35中的最小值是 : ' || c); 
END; 
#+end_src
*** 调用存储过程
#+begin_src sql
exec greetings;
/*或者*/
execute greetgins;

finMin(a,b,c);
#+end_src
*** 删除存储过程
#+begin_src sql
drop procedure greetings;
#+end_src

** 函数

*** 创建存储函数
#+begin_src sql
/*例子1-无参数*/
CREATE OR REPLACE FUNCTION totalEmp
   RETURN NUMBER
IS
   total   NUMBER := 0;
BEGIN
   SELECT COUNT (*) INTO total FROM emp;

   RETURN total;
END;

/*
 * 例子2-有参数
 * 计算并返回两个值中的最大值。
*/
CREATE OR REPLACE FUNCTION getMax (x IN NUMBER, y IN NUMBER)
   RETURN NUMBER
IS
   z   NUMBER;
BEGIN
   IF x > y
   THEN
      z := x;
   ELSE
      z := y;
   END IF;

   RETURN z;
END;
#+end_src
*** 调用存储函数
#+begin_src sql
DECLARE
   aa   NUMBER := 0;
BEGIN
   aa := totalEmp ();
   DBMS_OUTPUT.put_line (aa);
END;

SELECT COUNT (*) FROM emp;

/*例子2的调用*/
DECLARE
   a   NUMBER := &p_a;
   b   NUMBER := &p_b;
   c   NUMBER;
BEGIN
   c := getMax (a, b);
   DBMS_OUTPUT.put_line (a || b || '的最大值是' || c);
END;
#+end_src
*** 删除存储函数
#+begin_src sql
DROP FUNCTION function_name;
#+end_src
* 包
** 包的概念
首先,包是一个对象,模式的对象.其将逻辑上相关的PL/SQL分组.

一个包有两个强制性的部分:
- 包规范/格式
- 包体或定义
** 包规范
规范是包的接口.是声明(声明类型,变量,异常,游标和子程序,但是没有子程序的代码).

放置在规范中的对象被称为公共对象,放置在包体中的称为私有对象.
#+begin_src sql
CREATE PACKAGE cust_sal AS 
   PROCEDURE find_sal(c_id customers.id%type); 
END cust_sal;
#+end_src
** 包体
包体中存放规范中的各种声明所对应的代码以及其他私有声明.

用CREATE PACKAGE BODY语句创建包体.
#+begin_src sql
CREATE OR REPLACE PACKAGE BODY cust_sal AS
    PROCEDURE find_sal(c_id customers.id%TYPE) IS
        c_sal customers.salary%TYPE;
    BEGIN
        SELECT salary INTO c_sal
	FROM customers
	WHERE id = c_id;
	DBMS_OUTPUT.PUT_LINE('Salary:'||c_sal);
    END find_sal;
END cust_sal;
#+end_src
** 使用
#+begin_src sql
package_name.element_name
#+end_src
* 触发器
** 触发器的概念
就像手枪的扳机,你触发了,子弹就发射了.比如当你登录之后给你发一个"Welcome!"

以下事件可以触发"扳机":
- DML(delete,insert,update)
- DDL(create,alter,drop)
- 数据库操作(servererror,logon,logoff,startup,shutdown)
** TODO 创建
** TODO 触发