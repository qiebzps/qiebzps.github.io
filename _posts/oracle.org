#+title: Oracle 
#+author: 张鹏帅
#+date: 2020-11-02

* Oracle 基础
** 数据查询
参考: [[https://www.w3cschool.cn/oraclejc/oraclejc-e2ua2qu5.html][w3cschool]]
#+begin_src sql
/*单行数据查询*/
select colum_1 from table_name;

/*多行数据查询*/
select colum_1,colum_2,... from table_name;

/*全部数据查询*/
select * from table_name;
#+end_src

** 数据排序
参考: [[https://www.w3cschool.cn/oraclejc/oraclejc-xzfk2qv3.html][w3cschool]]
*** 正序/倒序
#+begin_src sql
select * from table_name order by asc; --正序

select * from table_name order by desc; --倒序
#+end_src
*** 空值处理
#+begin_src sql
select * from table_name order by [asc|desc] nulls first; --null排在最前

select * from table_name order by [asc|desc] nulls last; --null排在最后
#+end_src
*** 注意
1. 一条语句可拥有多条排序条件
    #+begin_src sql
    SELECT
        column_1,
        column_2,
        column_3,
        ...
    FROM
        table_name
    ORDER BY
        column_1 [ASC | DESC] [NULLS FIRST | NULLS LAST], -- 排序条件1
        column_1 [ASC | DESC] [NULLS FIRST | NULLS LAST], -- 排序条件2
    #+end_src
2. order by 子句总是select语句中的最后一个子句
** 数据过滤
参考: [[https://www.yiibai.com/oracle#h2--3-][易百教程]] [[https://www.w3cschool.cn/oraclejc/oraclejc-21an2qtd.html][w3cschool]]
*** DISTINCT
消除查询输出中的重复行。
#+begin_src sql
select distinct colun_1 from table_name;
#+end_src
*** WHERE
为查询返回结果集中的行记录指定过滤条件。
#+begin_src sql
/*假如colun_1存放的数字:找colun_1列值比3大的行*/
select colun_1 from table_name where colun_1>3;
#+end_src
*** AND
组合两个或两个以上的布尔表达式，如果所有表达式都为true，则返回true。
#+begin_src sql
/*假如colun_1存放的数字:找colun_1列值比3大比6小的行*/
select colun_1 from table_name where colun_1>3 and colun_1<6>;
#+end_src
*** OR
组合两个或两个以上的布尔表达式，如果其中一个表达式为true，则返回true。
#+begin_src sql
/*假如colun_1存放的数字:找colun_1列值比3小比6大的行*/
select colun_1 from table_name where colun_1<3 or colun_1>6>;
#+end_src
*** TODO FETCH
使用行限制子句限制查询返回的行数。
#+begin_src sql
/*!!!fetch子句是12c才提供的*/
/*在11g以下版本用行号*/
select * from emp where rownum <= 5;
/*无法直接用大于*/
select * from (select rownum r,e.* from emp e) where r >4;
#+end_src
*** IN
确定值是否与列表或子查询中的任何值相匹配。
#+begin_src sql
/*等价于r=1 or r=3 or r=4*/
select * from (select rownum r,e.* from emp e) where r in (1,3,4);
#+end_src
*** BETWEEN
基于一系列值(区间值)过滤数据。
#+begin_src sql
/*等价于r>=3 and r<=7*/
select * from (select rownum r,e.* from emp e) where r between 3 and 7;
#+end_src
*** LIKE
根据特定模式执行匹配。
#+begin_src sql
/*查找ename列中以K结尾的行*/
select * from emp where ename like '%K';
#+end_src
通配符
1. % : a%bc 代表一个或多个字符:a23webc
2. _ : a\under{}bc 代表一个字符:adbc

** 表的连接
参考: [[http://www.ruanyifeng.com/blog/2019/01/table-join.html][阮一峰的网络日志]] [[https://www.yiibai.com/oracle#h2--4-][易百教程]] [[https://blog.jooq.org/2016/07/05/say-no-to-venn-diagrams-when-explaining-joins/][Say NO to Venn Diagrams When Explaining JOINs]]
*** 表连接的理解
两张表根据关联字段组合成一个新的数据集.

A表中有张三和李四,B表中有李四和王五.
- 只返回两张表匹配的记录，这叫内连接（inner join）。
- 返回匹配的记录，以及表 A 多余的记录，这叫左连接（left join）。
- 返回匹配的记录，以及表 B 多余的记录，这叫右连接（right join）。
- 返回匹配的记录，以及表 A 和表 B 各自的多余记录，这叫全连接（full join）。
**PS:其实我觉得韦恩图我更好理解,两种都看理解得更透彻**

*** CROSS JOIN
连接都是基于cross join(笛卡尔积)的.
#+begin_src sql
select * from emp,dept;

select * from emp cross join dept;
#+end_src
**外连接(outer join)还包含不匹配的记录.所以,左连接,右连接,全连接都属于外连接.**
*** INNER JOIN
#+begin_src sql
select * from emp inner join dept on emp.deptno = dept.deptno;
#+end_src
*** LEFT JOIN
#+begin_src sql
select * from emp left join dept on emp.deptno = dept.deptno;
#+end_src
*** RIGHT JOIN
#+begin_src sql
select * from emp right join dept on emp.deptno = dept.deptno;
#+end_src
*** Full Join
#+begin_src sql
select * from emp e full join dept d on E.DEPTID=d.id;
#+end_src

** 数据分组
参考: [[https://www.yiibai.com/oracle#h2--5-][易百教程]]
*** GROUP BY
GROUP BY 子句是与[[聚合函数/分组函数][聚合函数/分组函数]]配合使用的.

为每一个分组应用当前的[[聚合函数/分组函数][聚合函数/分组函数]].
#+begin_src sql
/*聚合函数:计算总共有多少名员工*/
select count(*) from emp;

/*聚合函数+分组:计算个部门分别有多少名员工*/
select count(*) from emp group by deptid;
#+end_src
*** HAVING
HAVING 子句用来过滤应用过 GROUP BY 子句的行.
#+begin_src sql
/*聚合函数+分组:计算个部门分别有多少名员工,筛选出员工数大于2的*/
select count(*) from emp group by deptid having count(*)>2;
#+end_src
** 单行函数
参考: [[https://www.baidu.com/s?wd=%E8%B6%85%E8%AF%A6%E7%BB%86Oracle%E6%95%99%E7%A8%8B][超详细Oracle教程]] [[https://www.techonthenet.com/oracle/functions/to_char.php][TechOnTheNet]]
*** 字符函数
- upper
  #+begin_src sql
  select upper('abc') from dual;
  -- ABC
  #+end_src
- lower
  #+begin_src sql
  select lower('ABC') from dual;
  -- abc
  #+end_src
- initcap
  #+begin_src sql
  select initcap('initcap') from dual;
  -- Initcap
  #+end_src
- concat
  #+begin_src sql
  select concat('a','b') from dual;
  -- ab
  select 'a'||'b' from dual;
  -- ab
  #+end_src
- substr
  #+begin_src sql
  /*格式1:从第3个字符开始,截取后边所有字符*/
  /*0和1都代表第一个字符*/
  select substr('abcde',3) from dual;
  -- cde

  /*格式2:从第3个字符开始,截取后边2个字符*/
  select substr('abcde',3,2) from dual;
  -- cd
  #+end_src
- length
  #+begin_src sql
  select length('abcde') from dual;
  -- 5
  #+end_src
- replace
  #+begin_src sql
  select replace('abcde','de','aa') from dual;
  -- abcaa
  #+end_src
- instr
  #+begin_src sql
  /*格式1:返回子串在源串中的位置*/
  select instr('abcde','de') from dual;
  -- 4

  /*格式2:从第3个字符c开始,返回第2次出现'de'的位置*/
  select instr('abcdede','de',3,2) from dual;
  -- 6
  #+end_src
- lpad/rpad
  #+begin_src sql
  /*从左边开始截取或填充至6个字符*/
  select lpad('abc',6,'*') from dual;
  /*从右边开始截取或填充至6个字符*/
  select rpad('abc',6,'*') from dual; 
  #+end_src
- trim/ltrim/rtrim
  #+begin_src sql
  /*去除两端空格*/
  select trim('  abc  ') from dual;
  #+end_src

*** 数值函数
- round
  #+begin_src sql
  select round(3.456,2) from dual;
  -- 3.46
  #+end_src
- mod
  #+begin_src sql
  select mod(3.456,3) from dual;
  -- 0.456
  #+end_src
- trunc
  #+begin_src sql
  select trunc(3.456,2) from dual;
  -- 3.45
  #+end_src
- abs
  #+begin_src sql
  select abs(-3.456) from dual;
  -- 3.456
  #+end_src
- ceil
  #+begin_src sql
  select ceil(3.456) from dual;
  -- 4
  #+end_src
- floor
  #+begin_src sql
  select floor(3.456) from dual;
  -- 3
  #+end_src
- power
  #+begin_src sql
  select power(3,3) from dual;
  -- 27
  #+end_src
*** 转换函数
- to\under{}date
- to\under{}char
- to\under{}number
*** 日期函数
- months\under{}between
  #+begin_src sql
  select months_between(sysdate,to_date('20200727','yyyymmdd')) from dual;
  #+end_src
- add\under{}months
  #+begin_src sql
  select add_months(sysdate,1) from dual;
  #+end_src
- next\under{}day
  #+begin_src sql
  select next_day(sysdate,'星期三') from dual;
  #+end_src
- last\under{}day
  #+begin_src sql
  select last_day(sysdate) from dual;
  #+end_src
- sysdate
  #+begin_src sql
  select sysdate from dual;
  #+end_src
*** 通用函数
- nvl
  #+begin_src sql
  /*如果col_name列的某一行为空,那就用a代替*/
  -- nvl(col_name,a)
  select id,name,nvl(deptid,0) from temp1;
  #+end_src
- nvl2
  #+begin_src sql
  /*如果col_name列的某一行为空,那就用false代替否则用true*/
  -- nvl2(col_name,true,false)
  select id,name,nvl2(deptid,deptid,3) from temp1;
  #+end_src
- sys\under{}guid
  #+begin_src sql
  /*32位的随机数*/
  select sys_guid() from dual;
  #+end_src
- coalesce
  #+begin_src sql
  /*遇到第一个不是null的,返回*/
  select coalesce(null,null,3) from dual;
  #+end_src
- nullif
  #+begin_src sql
  /*如果相等返回null,否则返回expr1*/
  select nullif(deptid,20) from temp1;
  #+end_src
- case
  #+begin_src sql
  select 
  case
  when deptid = 20 then null
  else deptid
  end
  from temp1;
  #+end_src
- decode
  #+begin_src sql
  select decode(deptid,
  20,null,
  deptid)
  from emp;
  #+end_src

** 聚合函数/分组函数
- count
- avg
- max
- min
- sum
** 子查询
参考: [[https://www.baidu.com/s?wd=%E8%B6%85%E8%AF%A6%E7%BB%86Oracle%E6%95%99%E7%A8%8B][超详细Oracle教程]] [[https://baike.baidu.com/item/%E5%AD%90%E6%9F%A5%E8%AF%A2][百度百科]]
*** 子查询的概念
就是查询语句,但是这个语句是在另外一个语句中嵌套着的.

当一个查询是另一个查询的条件时,称之为子查询.

子查询的输出可以包括一个单独的值（单行子查询）、几行值（多行子查询）、或者多列数据（多列子查询）。

可用四种语法来创建了查询:
- 带有比较运算符的子查询
- 带有any或all谓词的子查询
- 带有in谓词的子查询
- 带有exists谓词的子查询
*** 带有比较运算符的子查询
    #+begin_src sql
    select sal from emp where sal >
    (select sal from emp where empno = 3333);
    #+end_src
*** 带有any或all谓词的子查询
    #+begin_src sql
    select sal from emp where sal > 
    any(select avg(sal) from emp group by deptno);

    select sal from emp where sal > 
    all(select avg(sal) from emp group by deptno);
    #+end_src
*** 带有in谓词的子查询
    #+begin_src sql
    select * from emp where deptid in
    (select id from dept);
    #+end_src
*** 带有exists谓词的子查询
    使用in谓词的子查询可以转换成exists谓词子查询
    #+begin_src sql
    /*in*/
    select * from emp where deptid in
    (select id from dept);
    /*exists*/
    select * from emp where exists 
    (select * from dept where dept.id = emp.deptid);
    #+end_src
*** topN查询
使用rownum来实现topN查询
#+begin_src sql
/*简单形式*/
select * from emp where rownum<3;
/*复杂形式*/
select r,e.* from 
(select rownum r,ee.* from emp ee) e where r>3;
-- 无法直接使用 select * from emp where rownum<3;
-- 原因是rownum是在查询结果出来之后才被添加上去的.
#+end_src
*** 分页查询
Oracle使用rownum来实现分布查询
** 操作符
参考: [[https://www.yiibai.com/oracle#h2--7-][易百教程]]
*** all
#+begin_src sql
SELECT
    *
FROM
    table_name
WHERE
    c > ALL (
        v1,
        v2,
        v3
    );

--  以上语句转换为 ALL 运算符后

SELECT
    *
FROM
    table_name
WHERE
    c > v1
    AND c > v2
    AND c > v3;
#+end_src
*** union
#+begin_src sql
/* 并集包含重复项 */
select * from EDW_INT_1
union
select * from EDW_INT_2;

/* 并集不包含重复项 */
select * from EDW_INT_1
union all
select * from EDW_INT_2;
#+end_src
*** intersect
#+begin_src sql
/* 交集 */
select * from EDW_INT_1
intersect
select * from EDW_INT_2;
#+end_src
*** minus
#+begin_src sql
/* 差集 */
select id from dept
minus
select deptid from emp;
#+end_src
** TODO 数据定义
** 修改数据 DML
*** insert
#+begin_src sql
insert into emp values(113,'Tom',40);

insert into emp(id,deptid) values(112,40);
#+end_src
*** insert into select 
#+begin_src sql
insert into emp (id,deptid) (
select id+100,deptid from emp
);
#+end_src
*** [#A] insert all/first
参考: [[http://blog.itpub.net/29196873/viewspace-1122075/][insert all用法讲解与实例]]
insert all 与insert first的区别就是,一条数据在insert all里面,会执行所有满足条件的后边的插入,而在insert first里面,哪怕一条数据所有条件都满足也只执行第一个满足条件的后边的插入.
#+begin_src sql
CREATE TABLE EDW_INT   
(   
  AGMT_NO         VARCHAR2(40 BYTE)             NOT NULL,   
  AGMT_SUB_NO     VARCHAR2(4 BYTE)              NOT NULL,   
  NEED_REPAY_INT  NUMBER(22,2),   
  CURR_PERIOD     NUMBER(4)                     NOT NULL   
);   
CREATE TABLE EDW_INT_1   
(   
  AGMT_NO         VARCHAR2(40 BYTE)             NOT NULL,   
  AGMT_SUB_NO     VARCHAR2(4 BYTE)              NOT NULL,   
  NEED_REPAY_INT  NUMBER(22,2),   
  CURR_PERIOD     NUMBER(4)                     NOT NULL   
);   
CREATE TABLE EDW_INT_2   
(   
  AGMT_NO         VARCHAR2(40 BYTE)             NOT NULL,   
  AGMT_SUB_NO     VARCHAR2(4 BYTE)              NOT NULL,   
  NEED_REPAY_INT  NUMBER(22,2),   
  CURR_PERIOD     NUMBER(4)                     NOT NULL   
); 

INSERT INTO EDW_INT   
  (AGMT_NO, AGMT_SUB_NO, NEED_REPAY_INT, CURR_PERIOD)   
VALUES   
  ('20003874', '2104', 3126.5, 7);   
INSERT INTO EDW_INT   
  (AGMT_NO, AGMT_SUB_NO, NEED_REPAY_INT, CURR_PERIOD)   
VALUES   
  ('20003874', '2104', 3290.76, 6);   
INSERT INTO EDW_INT   
  (AGMT_NO, AGMT_SUB_NO, NEED_REPAY_INT, CURR_PERIOD)   
VALUES   
  ('20003874', '2104', 3454.06, 5);   
INSERT INTO EDW_INT   
  (AGMT_NO, AGMT_SUB_NO, NEED_REPAY_INT, CURR_PERIOD)   
VALUES   
  ('20003874', '2104', 3616.41, 4);   
INSERT INTO EDW_INT   
  (AGMT_NO, AGMT_SUB_NO, NEED_REPAY_INT, CURR_PERIOD)   
VALUES   
  ('20017143', '2104', 2350.86, 0);   
INSERT INTO EDW_INT   
  (AGMT_NO, AGMT_SUB_NO, NEED_REPAY_INT, CURR_PERIOD)   
VALUES   
  ('20017143', '2104', 3566.55, 0);   
INSERT INTO EDW_INT   
  (AGMT_NO, AGMT_SUB_NO, NEED_REPAY_INT, CURR_PERIOD)   
VALUES   
  ('20018273', '2104', 1639.46, 0);   
INSERT INTO EDW_INT   
  (AGMT_NO, AGMT_SUB_NO, NEED_REPAY_INT, CURR_PERIOD)   
VALUES   
  ('20018273', '2104', 2080.49, 0);   
COMMIT;  

select * from EDW_INT;
select * from EDW_INT_1;
select * from EDW_INT_2;

truncate table EDW_INT_1;
truncate table EDW_INT_2;
/*insert all 不带条件*/
insert all 
into edw_int_1 values(agmt_no,agmt_sub_no,need_repay_int,curr_period)
into edw_int_2(agmt_no,agmt_sub_no,curr_period) values(agmt_no,'1234',curr_period)
select * from edw_int;

/*insert all 带条件*/
insert all
when ... then
    into table_name...
when ... then
    into table_name...
else
select ...;

/*insert first 带条件*/
insert first
when ... then
    into table_name...
when ... then
    into table_name...
else
select ...;
#+end_src
*** update
#+begin_src sql
UPDATE
    table_name
SET
    column1 = value1,
    column2 = value2,
    column3 = value3,
    ...
WHERE
condition;
#+end_src
*** delete
#+begin_src sql
DELETE
FROM
    table_name
WHERE
condition;
#+end_src
*** [#A] marge
参考: [[https://baike.baidu.com/item/merge][百度百科]] [[https://livesql.oracle.com/apex/livesql/file/content_PC76LRDFFAVI6P6LMCWJLBOP2.html][Oracle-livesql]]
#+begin_quote
MERGE是Oracle9i新增的语法，用来合并UPDATE和INSERT语句。
#+end_quote
#+begin_src sql
truncate table catalog1;
truncate table catalog2;

create table catalog1 (id number(3), item varchar2 (20), price number(6));

insert into catalog1 values(1, 'laptop', 800);
insert into catalog1 values(2, 'iphone', 500);
insert into catalog1 values(3, 'camera', 700);

select * from catalog1;

create table catalog2 (id number(3), item varchar2 (20), price number(6));

insert into catalog2 values(1, 'laptop', 899);
insert into catalog2 values(2, 'iphone', 599);
insert into catalog2 values(5, 'video camera', 799);

select * from catalog2;
/* 1:s1根据s2更新价格
 * 2:如果s2有s1没有,那就插入s1
 */
MERGE INTO catalog1 s1 USING catalog2 s2 ON (s1.id = s2.id) 
WHEN MATCHED THEN UPDATE SET s1.price = s2.price  
WHEN NOT MATCHED THEN INSERT (id, item, price) values (s2.id, s2.item, s2.price);

merge into catalog1 s1 using catalog2 s2 on(s1.id=s2.id)
when matched then update set s1.price = s2.price
when not matched then insert values(s2.id,s2.item,s2.price);
#+end_src
** TODO 修改表结构DDL
** 数据类型
参考: [[https://www.yiibai.com/oracle#h2--10-oracle-][易百教程]] [[https://www.baidu.com/s?wd=%E8%B6%85%E8%AF%A6%E7%BB%86Oracle%E6%95%99%E7%A8%8B][超详细Oracle教程]]
- char
- nchar
- varchar2
- nvarchar2
- number
- float
- date
- timestamp
- timestamp with time zone
- interval
- blob(binary 二进制流的大对象)
- clog(文件大对象)
** 约束
参考: [[https://www.baidu.com/s?wd=%E8%B6%85%E8%AF%A6%E7%BB%86Oracle%E6%95%99%E7%A8%8B][超详细Oracle教程]] 

约束就是对插入数据的各种限制.

可以在建表的时候直接声明,也可以为已建好的表添加约束.
*** not null:非空约束
#+begin_src sql
create table person(
pid number,
name varchar(30) not null
);
#+end_src
*** primary key:主键约束
#+begin_src sql
create table person(
pid number primary key,
name varchar(30) not null
);
#+end_src
*** unique:唯一性约束
#+begin_src sql
create table person(
pid number primary key,
name varchar(30) not null
tel varcha4(50) unique
);
#+end_src
*** check:条件约束
#+begin_src sql
create table person(
pid number primary key,
name varchar(30) not null
tel varcha4(50) unique
age number check (age between 0 and 150)
);
#+end_src

*** foreign key:外键约束
#+begin_src sql
create table book(
bid number primary key not null,
name varchar(50),
pid number
);

create table book(
bid number primary key not null,
name varchar(50),
pid number references person(pid) on delete cascade
-- constraint book_pid_fk foreign key(pid) references person(pid) on delete cascade
);
#+end_src
*** 级联删除 on delete cascade
如果person中的一条数据没了,对应book中的数据也应该同时消失.
*** 禁用约束
#+begin_src sql
alert table book disable constraint person_book_pid_fk;
#+end_src
*** 启用约束
#+begin_src sql
alert table book enable constraint person_book_pid_fk;
#+end_src
*** 删除约束
#+begin_src sql
alert table book drop constraint person_book_pid_fk;
alert table student drop unique(tel);
#+end_src
** 视图
参考: [[https://www.baidu.com/s?wd=%E8%B6%85%E8%AF%A6%E7%BB%86Oracle%E6%95%99%E7%A8%8B][超详细Oracle教程]] 
就是一个封装了各种复杂查询的语句.
*** 创建视图
#+begin_src sql
create view empv20(empno,ename,sal) as
select empno,ename,sal from emp where deptno=20;
#+end_src
*** 查看视图
#+begin_src sql
select text from user_views;
#+end_src
** TODO 索引
   :LOGBOOK:
   CLOCK: [2020-11-09 Mon 11:16]--[2020-11-09 Mon 11:38] =>  0:22
   :END:
参考: [[https://www.baidu.com/s?wd=%E8%B6%85%E8%AF%A6%E7%BB%86Oracle%E6%95%99%E7%A8%8B][超详细Oracle教程]] 
*** 什么是索引
在没有索引的时候,想要找到某个数据,需要对全表进行扫描.

索引是通过建立B树索引或位图索引来两种方式来提高检索速度.

- 创建索引有两种方式:
  1. 自动创建-主键与唯一约束时系统会自动在相应的字段创建唯一性索引
  2. 手动创建

- 索引的缺点:
  1. 需要占用物理空间
  2. 当对表中的数据进行增加,删除和修改的时候,索引也要动态的维护,降低了数据的维护速度.
*** TODO 索引的分类
  1. 唯一性索引
  2. 非唯一性索引
*** 与索引有关的数据字典
#+begin_src sql
select * from user_indexes; -- 查询现在索引
select * from user_ind_columns; -- 索引建立在哪些字段上
#+end_src
*** 创建索引的原则
1. 在select操作占大部分的表上创建索引
2. 在where子句中出现最频繁的列上创建索引
3. 小于 5M 的表，最好不要使用索引来查询，表越小，越适合用全表扫描。
*** 创建索引
#+begin_src sql
create index abc on student(sid,sname);
create index abc1 on student(sname,sid);
-- 索引abc对select * from student where sid=1;这样的语句更有效
-- 索引abc1对select * from student where sname='louis';这样的语句更有效
#+end_src
*** 删除索引
#+begin_src sql
drop index abc1;
#+end_src
*** TODO B树索引
*** TODO 位图索引
** 数据字典
参考: [[https://www.baidu.com/s?wd=%E8%B6%85%E8%AF%A6%E7%BB%86Oracle%E6%95%99%E7%A8%8B][超详细Oracle教程]] [[https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8][百度百科]]
*** 什么是数据字典?
直观点说就是一张表,表中的内容是对数据的数据项,数据结构,数据流,数据存储,处理逻辑等进行定义和描述.
*** 分类1
**** 主动数据字典
内容可以由DBMS自动更新.
**** 被动数据字典
内容需要手动更新.

*** 分类2
数据字典中的表是不能直接被访问的,但是可以访问数据字典中的视图.

为了便于用户对数据字典表的查询,Oracle对这些数据字典都分别建立了用户视图.
**** 数据字典表
**** 数据字典视图
***** 静态数据字典(静态性能视图)
****** user_*
该视图存储了关于当前所拥有的对象的信息.即所有在该用户模式下的对象.
****** all_*
该视图存储了当前用户能够访问的对象的信息,不一定是该用户所拥有的对象,只需要有访问该对象的权限即可.
****** dba_*
该视图存储了数据库中所有对象的信息.
***** 动态数据字典(动态性能视图)
动态性能视图又叫V$视图,之所以这样叫是因为他们都以V$或GV$开关的.这些视图会不断的进行更新,从而提供了关于内存和磁盘的运行情况.只能访问能修改.只存在于数据库运行期间.
**** 例子
1. 查询某用户下所有表
   #+begin_src sql
   select table_name from all_tables where owner='SCOTT';
   #+end_src
2. 查询EMP表中所有字段
   #+begin_src sql
   select * from all_tab_columns where table_name='EMP';
   #+end_src
3. 列出一的索引列
   #+begin_src sql
   select * from sys.all_ind_columns where table_name='EMP';
   #+end_src
4. 列出表中的约束
   #+begin_src sql
   select * from all_constraints where table_name='EMP';
   #+end_src
5. DICTIONARY:Description of data dictionary tables and views
   #+begin_src sql
   select * from dictionary where table_name='DICTIONARY';
   #+end_src
   
** TODO 用户管理
** TODO 备份 恢复 SQLLoader
** TODO 数据库设计范式
** TODO SQL优化
* [[file:plsql程序设计_学习笔记.org][PL/SQL程序设计]]
